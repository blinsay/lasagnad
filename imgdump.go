package main

import (
	"bytes"
	"context"
	"crypto/md5"
	"encoding/hex"
	"fmt"
	"image"
	"io"
	"io/ioutil"
	"mime"
	"net/http"
	"net/url"
	"path/filepath"
	"strconv"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/service/s3"
	"github.com/pkg/errors"

	_ "image/gif"
	_ "image/jpeg"
	_ "image/png"
)

const (
	userAgentHeader     = "User-Agent"
	userAgent           = "lasagnad/4.20"
	acceptHeader        = "Accept"
	contentLengthHeader = "Content-Length"
)

var (
	// ErrTooLarge is returned from fetchImageBytes when the image fetch is over
	// the size limit.
	ErrTooLarge = fmt.Errorf("image: too large")

	// ErrBadResponseCode is returned from fetchImageBytes when the response to a
	// fetch request isn't a 200.
	ErrBadResponseCode = fmt.Errorf("image: bad response code")

	// ErrBadImage is returned from fetchImageBytes when the content of the
	// response can't be decoded as an image.
	ErrBadImage = fmt.Errorf("image: bad image")
)

// fetch the image at the given URL. runs the image through image.Decode to make
// sure it's a valid image and returns ErrBadImage if it's not recognized.
//
// also limits the size of the images fetched. returns ErrTooLarge if the image
func fetchImageBytes(ctx context.Context, client *http.Client, url *url.URL, sizeLimit int64) ([]byte, string, error) {
	req, err := http.NewRequest(http.MethodGet, url.String(), nil)
	if err != nil {
		return nil, "", errors.Wrap(err, "image: bad http request")
	}

	req = req.WithContext(ctx)
	req.Header.Set(userAgentHeader, userAgent)
	req.Header.Set(acceptHeader, "image/*")

	resp, err := client.Do(req)
	if err != nil {
		return nil, "", errors.Wrap(err, "image: http request failed")
	}
	// TODO(benl): there shoul dbe some way to inspect this response for debugging
	// weird links. deal with that when it comes up.
	if resp.StatusCode != 200 {
		return nil, "", ErrBadResponseCode
	}

	if contentLengthTooLarge(resp, sizeLimit) {
		return nil, "", ErrTooLarge
	}

	defer resp.Body.Close()
	bs, err := ioutil.ReadAll(io.LimitReader(resp.Body, sizeLimit))
	if err != nil {
		return nil, "", errors.Wrap(err, "image: reading data failed")
	}

	// try to decode the bytes as an image. this check could only sniff the image
	// type but that wouldn't catch cases where there's mangled bytes at the end
	// of the data. if that doesn't happen often and this is slow, maybe switch to
	// image.DecodeConfig instead of image.Decode
	_, filetype, err := image.Decode(bytes.NewReader(bs))
	if err != nil {
		return nil, "", ErrBadImage
	}

	return bs, filetype, nil
}

func contentLengthTooLarge(r *http.Response, limit int64) bool {
	headerValue := r.Header.Get(contentLengthHeader)
	if headerValue == "" {
		return false
	}

	contentLength, err := strconv.ParseInt(headerValue, 10, 64)
	if err != nil {
		return false
	}

	return contentLength > limit
}

// an imgid is the md5 checksum of an images bytes. it's used to identify the
// image in s3 and urls.
type imgid = [md5.Size]byte

// an img is an image that's been uploaded to storage. it's already been
// digested and has an id, a filetype, and a url.
type img struct {
	Name     string
	ID       imgid
	Filetype string
	URL      *url.URL
}

// an imgdump is a bunch of images stored in an s3 bucket. images are given a
// name to look them up by later, but multiple images may have the same name -
// they're uniquely identified by the MD5 of their content.
//
// given that, an imgdump needs a name and an ID to look up an image directly.
// when looking up images by name, the best an imgdump can do is list all of the
// images with the same name.
//
// images are stored under some prefix so as not to pollute the bucket used.
//
// the S3 URL for an image is constructed as follows:
//
//		s3://bucket/<prefix>/<name1>/<image_md5>.<filetype>
//
// an s3 bucket with a few images already in it might look like:
//
//    s3://some-bucket/once/told/me/wizard/7a1030242704ebe5c0fad16d9f56d785.jpg
//    s3://some-bucket/once/told/me/wizard/d769203fb5cd47d1f2b82e56028f3d45.png
//    s3://some-bucket/once/told/me/garf/f4369905865d32042ddc3c025d45eb50.png
//
type imgdump struct {
	Bucket string
	Prefix string
	S3     *s3.S3
}

// add an image to the dump. this will overwrite an existing key if and only if
// the image bytes, filetype, and the name are identical.
func (dump *imgdump) add(ctx context.Context, name, filetype string, bs []byte, metadata map[string]*string) (*img, error) {
	imgid := md5.Sum(bs)
	key := s3key(dump.Prefix, name, filetype, imgid)
	// NOTE(benl): filetype should be generated by image.Decode so we're going to
	// assume that image/filetype is a valid mime type. even if it's not, maybe
	// just image/whatever is ok?
	mimeType := fmt.Sprintf("image/%s", filetype)

	_, err := dump.S3.PutObjectWithContext(ctx, &s3.PutObjectInput{
		Bucket:      &dump.Bucket,
		Key:         &key,
		Body:        bytes.NewReader(bs),
		ACL:         aws.String("public-read"),
		ContentType: &mimeType,
		Metadata:    metadata,
	})

	if err != nil {
		return nil, errors.Wrap(err, "upload failed")
	}

	return &img{
		Name:     name,
		ID:       imgid,
		Filetype: filetype,
		URL:      s3url(dump.Bucket, dump.Prefix, name, filetype, imgid),
	}, nil
}

// list all images with the given name.
func (dump *imgdump) list(ctx context.Context, name string) ([]img, error) {
	// NOTE(benl): this buffers everything into memory. there are probably only
	// ever going to be at most a few hundred of these, so that is A-OK for now.
	// if that changes, revisit this!
	prefix := s3prefix(dump.Prefix, name)

	var imgs []img
	var marker string

	for {
		request := &s3.ListObjectsInput{
			Bucket: &dump.Bucket,
			Prefix: &prefix,
		}
		if marker != "" {
			request.Marker = &marker
		}

		// NOTE: the S3 client (probably?) checks the context for timeouts and
		// cancellation before sending a request, so it doesn't have to get checked
		// manually elsewhere in this loop.
		resp, err := dump.S3.ListObjectsWithContext(ctx, request)
		if err != nil {
			return nil, errors.Wrap(err, "listing images failed")
		}

		for _, obj := range resp.Contents {
			imgid, filetype, err := idAndFiletype(*obj.Key)
			if err != nil {
				return nil, errors.Wrap(err, fmt.Sprintf("imgdump: found invalid image key: %q", *obj.Key))
			}
			imgs = append(imgs, img{
				Name:     name,
				ID:       imgid,
				Filetype: filetype,
				URL:      s3url(dump.Bucket, dump.Prefix, name, filetype, imgid),
			})
		}

		if !*resp.IsTruncated {
			break
		}
		marker = *resp.Contents[len(resp.Contents)-1].Key
	}

	return imgs, nil
}

// make an s3 key. should only be called from imgdump
func s3key(prefix, name, filetype string, id imgid) string {
	extensions, err := mime.ExtensionsByType("image/" + filetype)
	if err != nil {
		panic(fmt.Sprintf("illegal image mime type %q! error=%q", filetype, err))
	}
	if len(extensions) == 0 {
		panic(fmt.Sprintf("unknown image mime type %q!", filetype))
	}
	ext := extensions[0]
	filename := fmt.Sprintf("%x%s", id, ext)

	return filepath.Join(prefix, name, filename)
}

// make an s3 prefix for listing a bucket. should only be called from imgdump
func s3prefix(prefix, name string) string {
	return filepath.Join(prefix, name)
}

// make an s3 url. should only be called from imgdump
func s3url(bucket, prefix, name, filetype string, id imgid) *url.URL {
	extensions, err := mime.ExtensionsByType("image/" + filetype)
	if err != nil {
		panic(fmt.Sprintf("illegal image mime type %q! error=%q", filetype, err))
	}
	if len(extensions) == 0 {
		panic(fmt.Sprintf("unknown image mime type %q!", filetype))
	}
	ext := extensions[0]

	filename := fmt.Sprintf("%x%s", id, ext)

	u := &url.URL{}
	u.Scheme = "https"
	u.Host = fmt.Sprintf("%s.s3.amazonaws.com", bucket)
	u.Path = filepath.Join(prefix, name, filename)
	return u
}

// parse an imgid and filetype from an s3key. assumes the key was constructed
// by the s3key func
func idAndFiletype(s3key string) (imgid, string, error) {
	filename := filepath.Base(s3key)
	ext := filepath.Ext(filename)

	mimeType := mime.TypeByExtension(ext)
	if mimeType == "" {
		return imgid{}, "", fmt.Errorf("unknown mime type")
	}
	filetype := mimeType[len("image/"):]

	id, err := imgidFromString(filename[:len(filename)-len(ext)])
	if err != nil {
		return imgid{}, "", nil
	}

	return id, filetype, nil
}

func imgidFromString(str string) (imgid, error) {
	var id imgid
	bs, err := hex.DecodeString(str)
	if err != nil || len(bs) != md5.Size {
		return id, err
	}
	copy(id[:], bs)
	return id, nil
}
